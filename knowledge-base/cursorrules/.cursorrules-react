# KellerAI React Development Standards
# .cursorrules for React Projects
# Version: 1.0
# Last Updated: 2025-10-14

## Project Context
This ruleset applies to KellerAI React projects including web applications, dashboards, and component libraries with emphasis on performance, accessibility, and modern React patterns.

## React Version and Patterns

### Modern React (17+)
- Use functional components with hooks (no class components)
- No need for `React` import in JSX files (automatic JSX transform)
- Use TypeScript for all components
- Leverage React 18+ features (concurrent rendering, transitions, suspense)

## Component Structure

### Functional Component Template
```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';
import type { FC, ReactNode } from 'react';

interface UserProfileProps {
  /** User ID to display */
  userId: string;
  /** Optional custom styling */
  className?: string;
  /** Callback when profile is updated */
  onUpdate?: (user: User) => void;
  /** Child elements to render */
  children?: ReactNode;
}

/**
 * UserProfile component displays user information and allows editing.
 *
 * @example
 * ```tsx
 * <UserProfile
 *   userId="123"
 *   onUpdate={(user) => console.log('Updated:', user)}
 * />
 * ```
 */
export const UserProfile: FC<UserProfileProps> = ({
  userId,
  className,
  onUpdate,
  children,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let cancelled = false;

    const loadUser = async () => {
      try {
        setLoading(true);
        const userData = await fetchUser(userId);
        if (!cancelled) {
          setUser(userData);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err instanceof Error ? err : new Error('Unknown error'));
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    loadUser();

    return () => {
      cancelled = true;
    };
  }, [userId]);

  const handleUpdate = useCallback(
    (updatedUser: User) => {
      setUser(updatedUser);
      onUpdate?.(updatedUser);
    },
    [onUpdate]
  );

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return null;

  return (
    <div className={className}>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      {children}
    </div>
  );
};
```

### Component File Organization
```
components/
├── UserProfile/
│   ├── UserProfile.tsx          # Main component
│   ├── UserProfile.test.tsx     # Tests
│   ├── UserProfile.module.css   # Styles
│   ├── UserProfile.stories.tsx  # Storybook stories (optional)
│   ├── types.ts                 # Component-specific types
│   ├── hooks.ts                 # Component-specific hooks
│   └── index.ts                 # Barrel export
```

## Hooks Best Practices

### useState
```typescript
// ✅ GOOD - Typed state
const [user, setUser] = useState<User | null>(null);
const [count, setCount] = useState(0);
const [isOpen, setIsOpen] = useState(false);

// ✅ GOOD - Functional updates for dependent state
const [count, setCount] = useState(0);
setCount(prev => prev + 1);

// ❌ BAD - Relying on current state
setCount(count + 1); // Can be stale in async contexts
```

### useEffect
```typescript
// ✅ GOOD - Proper cleanup and dependency array
useEffect(() => {
  const controller = new AbortController();

  const fetchData = async () => {
    try {
      const response = await fetch('/api/data', {
        signal: controller.signal,
      });
      const data = await response.json();
      setData(data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        setError(error);
      }
    }
  };

  fetchData();

  return () => {
    controller.abort();
  };
}, [userId]); // Include all dependencies

// ❌ BAD - Missing cleanup
useEffect(() => {
  fetch('/api/data').then(res => res.json()).then(setData);
}, []); // No cleanup, no error handling

// ❌ BAD - Missing dependencies
useEffect(() => {
  fetchUser(userId); // userId not in deps
}, []); // Will use stale userId

// ✅ GOOD - Effect runs only on mount
useEffect(() => {
  logPageView();
}, []); // Explicitly empty deps because no external values used
```

### useCallback
```typescript
// ✅ GOOD - Memoize callback to prevent child re-renders
const handleSubmit = useCallback(
  async (data: FormData) => {
    setLoading(true);
    try {
      await submitForm(data);
      onSuccess?.();
    } catch (error) {
      setError(error);
    } finally {
      setLoading(false);
    }
  },
  [onSuccess] // Only recreate if onSuccess changes
);

// ❌ BAD - Creating new function on every render
const handleSubmit = (data: FormData) => {
  // This creates a new function on every render
  // Causes child components to re-render unnecessarily
};
```

### useMemo
```typescript
// ✅ GOOD - Memoize expensive computations
const filteredUsers = useMemo(() => {
  return users.filter(user =>
    user.name.toLowerCase().includes(searchQuery.toLowerCase())
  );
}, [users, searchQuery]);

// ✅ GOOD - Memoize complex object creation
const chartConfig = useMemo(
  () => ({
    data: processedData,
    options: {
      responsive: true,
      maintainAspectRatio: false,
    },
  }),
  [processedData]
);

// ❌ BAD - Overusing useMemo for simple operations
const doubled = useMemo(() => count * 2, [count]); // Too simple, not worth it
```

### Custom Hooks
```typescript
/**
 * Custom hook for fetching and managing user data.
 *
 * @param userId - ID of the user to fetch
 * @returns User data, loading state, error, and refetch function
 *
 * @example
 * ```tsx
 * const { user, loading, error, refetch } = useUser('123');
 * ```
 */
function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchUser = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const userData = await getUserById(userId);
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch user'));
    } finally {
      setLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  return { user, loading, error, refetch: fetchUser };
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { user, loading, error, refetch } = useUser(userId);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return null;

  return (
    <div>
      <h2>{user.name}</h2>
      <button onClick={refetch}>Refresh</button>
    </div>
  );
}
```

### useRef
```typescript
// ✅ GOOD - DOM references
function AutoFocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  return <input ref={inputRef} />;
}

// ✅ GOOD - Mutable values that don't trigger re-renders
function Timer() {
  const intervalRef = useRef<NodeJS.Timeout>();
  const [count, setCount] = useState(0);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      setCount(c => c + 1);
    }, 1000);

    return () => {
      clearInterval(intervalRef.current);
    };
  }, []);

  return <div>Count: {count}</div>;
}
```

## Performance Optimization

### React.memo
```typescript
// ✅ GOOD - Memoize pure components
interface UserCardProps {
  user: User;
  onSelect: (id: string) => void;
}

export const UserCard = React.memo<UserCardProps>(({ user, onSelect }) => {
  return (
    <div onClick={() => onSelect(user.id)}>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
});

UserCard.displayName = 'UserCard';

// Custom comparison function for complex props
export const UserList = React.memo<UserListProps>(
  ({ users, selectedId }) => {
    // Component implementation
  },
  (prevProps, nextProps) => {
    // Custom comparison logic
    return (
      prevProps.selectedId === nextProps.selectedId &&
      prevProps.users.length === nextProps.users.length
    );
  }
);
```

### Code Splitting and Lazy Loading
```typescript
import { lazy, Suspense } from 'react';

// ✅ GOOD - Lazy load heavy components
const HeavyChart = lazy(() => import('./components/HeavyChart'));
const AdminPanel = lazy(() => import('./pages/AdminPanel'));

function Dashboard() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <HeavyChart data={chartData} />
    </Suspense>
  );
}

// ✅ GOOD - Route-based code splitting
const routes = [
  {
    path: '/',
    element: <HomePage />,
  },
  {
    path: '/admin',
    element: (
      <Suspense fallback={<PageLoader />}>
        <AdminPanel />
      </Suspense>
    ),
  },
];
```

### Virtual Lists for Large Data
```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualUserList({ users }: { users: User[] }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: users.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50, // Estimated item height
    overscan: 5, // Render 5 items above and below viewport
  });

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            <UserCard user={users[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

## State Management

### Local State vs Global State
```typescript
// ✅ GOOD - Use local state for UI-specific state
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false); // Local UI state
  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>
      {isOpen && <DropdownMenu />}
    </div>
  );
}

// ✅ GOOD - Use context for shared state
interface ThemeContextValue {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = useCallback(() => {
    setTheme(prev => (prev === 'light' ? 'dark' : 'light'));
  }, []);

  const value = useMemo(() => ({ theme, toggleTheme }), [theme, toggleTheme]);

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}
```

### Zustand for Complex State
```typescript
import { create } from 'zustand';

interface UserStore {
  users: User[];
  selectedUser: User | null;
  loading: boolean;
  fetchUsers: () => Promise<void>;
  selectUser: (userId: string) => void;
  clearSelection: () => void;
}

export const useUserStore = create<UserStore>((set, get) => ({
  users: [],
  selectedUser: null,
  loading: false,

  fetchUsers: async () => {
    set({ loading: true });
    try {
      const users = await fetchUsersApi();
      set({ users, loading: false });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },

  selectUser: (userId) => {
    const user = get().users.find(u => u.id === userId);
    set({ selectedUser: user || null });
  },

  clearSelection: () => {
    set({ selectedUser: null });
  },
}));

// Usage
function UserList() {
  const users = useUserStore(state => state.users);
  const selectUser = useUserStore(state => state.selectUser);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id} onClick={() => selectUser(user.id)}>
          {user.name}
        </li>
      ))}
    </ul>
  );
}
```

## Forms and Validation

### React Hook Form
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Define validation schema
const userSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  age: z.number().int().min(18, 'Must be at least 18 years old'),
  role: z.enum(['admin', 'user', 'guest']),
});

type UserFormData = z.infer<typeof userSchema>;

function UserForm({ onSubmit }: { onSubmit: (data: UserFormData) => void }) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      name: '',
      email: '',
      age: 18,
      role: 'user',
    },
  });

  const onSubmitForm = async (data: UserFormData) => {
    try {
      await onSubmit(data);
      reset();
    } catch (error) {
      console.error('Form submission failed:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmitForm)}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" {...register('name')} />
        {errors.name && <span role="alert">{errors.name.message}</span>}
      </div>

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="email" {...register('email')} />
        {errors.email && <span role="alert">{errors.email.message}</span>}
      </div>

      <div>
        <label htmlFor="age">Age</label>
        <input id="age" type="number" {...register('age', { valueAsNumber: true })} />
        {errors.age && <span role="alert">{errors.age.message}</span>}
      </div>

      <div>
        <label htmlFor="role">Role</label>
        <select id="role" {...register('role')}>
          <option value="user">User</option>
          <option value="admin">Admin</option>
          <option value="guest">Guest</option>
        </select>
        {errors.role && <span role="alert">{errors.role.message}</span>}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

## Accessibility (A11y)

### Semantic HTML
```typescript
// ✅ GOOD - Semantic HTML with proper ARIA
function ArticleCard({ article }: { article: Article }) {
  return (
    <article>
      <header>
        <h2>{article.title}</h2>
        <time dateTime={article.publishedAt.toISOString()}>
          {formatDate(article.publishedAt)}
        </time>
      </header>
      <p>{article.excerpt}</p>
      <footer>
        <a href={`/articles/${article.id}`}>Read more</a>
      </footer>
    </article>
  );
}

// ❌ BAD - Div soup
function ArticleCard({ article }: { article: Article }) {
  return (
    <div>
      <div>
        <div>{article.title}</div>
        <div>{article.publishedAt}</div>
      </div>
      <div>{article.excerpt}</div>
      <div onClick={() => navigate(`/articles/${article.id}`)}>Read more</div>
    </div>
  );
}
```

### Keyboard Navigation
```typescript
// ✅ GOOD - Keyboard accessible custom button
function CustomButton({ onClick, children }: { onClick: () => void; children: ReactNode }) {
  return (
    <button
      onClick={onClick}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onClick();
        }
      }}
    >
      {children}
    </button>
  );
}

// ✅ GOOD - Keyboard accessible dropdown
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const buttonRef = useRef<HTMLButtonElement>(null);

  return (
    <div>
      <button
        ref={buttonRef}
        onClick={() => setIsOpen(!isOpen)}
        aria-expanded={isOpen}
        aria-haspopup="true"
        aria-controls="dropdown-menu"
      >
        Menu
      </button>
      {isOpen && (
        <ul id="dropdown-menu" role="menu">
          <li role="menuitem">
            <button onClick={() => console.log('Option 1')}>Option 1</button>
          </li>
          <li role="menuitem">
            <button onClick={() => console.log('Option 2')}>Option 2</button>
          </li>
        </ul>
      )}
    </div>
  );
}
```

### Screen Reader Support
```typescript
// ✅ GOOD - Accessible loading state
function DataTable({ loading }: { loading: boolean }) {
  return (
    <div>
      {loading && (
        <div role="status" aria-live="polite">
          <span className="sr-only">Loading data...</span>
          <LoadingSpinner aria-hidden="true" />
        </div>
      )}
      {/* Table content */}
    </div>
  );
}

// ✅ GOOD - Accessible form errors
function FormField({ error }: { error?: string }) {
  const errorId = useId();

  return (
    <div>
      <label htmlFor="email">Email</label>
      <input
        id="email"
        aria-invalid={!!error}
        aria-describedby={error ? errorId : undefined}
      />
      {error && (
        <span id={errorId} role="alert">
          {error}
        </span>
      )}
    </div>
  );
}
```

## Error Handling

### Error Boundaries
```typescript
import { Component, type ReactNode } from 'react';

interface ErrorBoundaryProps {
  fallback?: ReactNode;
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Log to error reporting service
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div role="alert">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error?.message}</pre>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary fallback={<ErrorPage />}>
      <Router>
        <Routes />
      </Router>
    </ErrorBoundary>
  );
}
```

## Testing with React Testing Library

### Component Testing
```typescript
import { render, screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserProfile } from './UserProfile';

describe('UserProfile', () => {
  it('should display user information', async () => {
    // Arrange
    const mockUser = {
      id: '1',
      name: 'Alice',
      email: 'alice@example.com',
    };
    vi.mocked(fetchUser).mockResolvedValue(mockUser);

    // Act
    render(<UserProfile userId="1" />);

    // Assert
    await waitFor(() => {
      expect(screen.getByText('Alice')).toBeInTheDocument();
      expect(screen.getByText('alice@example.com')).toBeInTheDocument();
    });
  });

  it('should handle user interaction', async () => {
    // Arrange
    const user = userEvent.setup();
    const mockOnUpdate = vi.fn();
    render(<UserProfile userId="1" onUpdate={mockOnUpdate} />);

    // Act
    const editButton = screen.getByRole('button', { name: /edit/i });
    await user.click(editButton);

    const nameInput = screen.getByLabelText(/name/i);
    await user.clear(nameInput);
    await user.type(nameInput, 'New Name');

    const saveButton = screen.getByRole('button', { name: /save/i });
    await user.click(saveButton);

    // Assert
    await waitFor(() => {
      expect(mockOnUpdate).toHaveBeenCalledWith(
        expect.objectContaining({ name: 'New Name' })
      );
    });
  });

  it('should show error state', async () => {
    // Arrange
    const error = new Error('Failed to fetch user');
    vi.mocked(fetchUser).mockRejectedValue(error);

    // Act
    render(<UserProfile userId="1" />);

    // Assert
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent('Failed to fetch user');
    });
  });
});
```

## Code Review Checklist

Before submitting React code for review, verify:

- [ ] Using functional components with hooks (no class components)
- [ ] All components have TypeScript prop types
- [ ] Proper hook dependencies in useEffect/useCallback/useMemo
- [ ] Cleanup functions for effects with side effects
- [ ] Accessibility attributes (ARIA, semantic HTML)
- [ ] Keyboard navigation support
- [ ] Loading and error states handled
- [ ] Performance optimization (memo, useMemo, useCallback where needed)
- [ ] No prop drilling (use context or state management)
- [ ] Tests cover user interactions and edge cases
- [ ] No console.log in production code
- [ ] Proper error boundaries for error handling
- [ ] Code splitting for large components

## Common Anti-Patterns to Avoid

### 1. Not Including Dependencies in useEffect
```typescript
// ❌ BAD
useEffect(() => {
  fetchUser(userId); // userId not in deps
}, []);

// ✅ GOOD
useEffect(() => {
  fetchUser(userId);
}, [userId]);
```

### 2. Creating Functions Inside Render
```typescript
// ❌ BAD - New function on every render
function UserList({ users }: { users: User[] }) {
  return users.map(user => (
    <UserCard
      key={user.id}
      user={user}
      onSelect={() => selectUser(user.id)} // New function every render
    />
  ));
}

// ✅ GOOD - Memoized callback
function UserList({ users }: { users: User[] }) {
  const handleSelect = useCallback((userId: string) => {
    selectUser(userId);
  }, []);

  return users.map(user => (
    <UserCard key={user.id} user={user} onSelect={handleSelect} />
  ));
}
```

### 3. Not Using Keys Properly
```typescript
// ❌ BAD - Using index as key
{items.map((item, index) => (
  <Item key={index} {...item} />
))}

// ✅ GOOD - Using stable unique ID
{items.map(item => (
  <Item key={item.id} {...item} />
))}
```

---

**Last Updated**: 2025-10-14
**Maintainer**: KellerAI Engineering Team
**Questions**: Contact the platform team for clarifications
