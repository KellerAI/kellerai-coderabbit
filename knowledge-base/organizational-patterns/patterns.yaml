# KellerAI Organizational Patterns
# Cross-Repository Learning System
#
# This file contains code patterns, architectural decisions, and best practices
# that have been validated across multiple KellerAI repositories.
#
# Pattern Confidence Scoring:
# - 0.95-1.0: Critical patterns (security, breaking changes)
# - 0.85-0.94: High confidence (used in 5+ repos)
# - 0.75-0.84: Medium confidence (used in 3-4 repos)
# - 0.60-0.74: Experimental (used in 1-2 repos)

version: "1.0.0"
last_updated: "2025-10-14"
total_patterns: 5

metadata:
  learning_enabled: true
  auto_suggestion: true
  feedback_tracking: true
  min_confidence_for_suggestion: 0.75

patterns:
  # Pattern 1: FastAPI Dependency Injection
  - id: "py-fastapi-dependency-injection"
    category: "code_structure"
    language: "python"
    framework: "fastapi"
    title: "FastAPI Dependency Injection Pattern"
    confidence: 0.92
    occurrences: 23
    repositories:
      - "kellerai/api-service"
      - "kellerai/auth-service"
      - "kellerai/notification-service"
    
    description: |
      Use FastAPI Depends() for all service layer dependencies in API routes
      to enable testability and maintainability.
    
    pattern:
      code: |
        from fastapi import Depends
        from app.services import UserService
        
        @router.post("/users")
        async def create_user(
            user_data: UserCreate,
            user_service: UserService = Depends(get_user_service)
        ):
            return await user_service.create_user(user_data)
      
      detection:
        file_pattern: "**/routers/**/*.py"
        code_pattern: "@router\\.(get|post|put|delete|patch)\\("
        context: ["fastapi", "APIRouter"]
    
    anti_pattern:
      code: |
        # Anti-pattern: Direct instantiation
        @router.post("/users")
        async def create_user(user_data: UserCreate):
            user_service = UserService()  # Tight coupling
            return await user_service.create_user(user_data)
      
      detection:
        pattern: "\\w+Service\\(\\)"
        context: ["@router"]
    
    benefits:
      - "Improved testability through dependency injection"
      - "Better separation of concerns"
      - "Easier mocking for unit tests"
      - "Consistent service instantiation"
    
    when_to_apply:
      - "API route handlers requiring service layer access"
      - "Functions needing database connections or external clients"
      - "Endpoints requiring authentication or authorization"
    
    references:
      - url: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        title: "FastAPI Dependencies Documentation"
      - internal: "docs/standards/coding-standards.yaml"
        section: "dependency_injection"
    
    success_metrics:
      suggestions_made: 47
      accepted: 41
      rejected: 6
      acceptance_rate: 0.87
      positive_feedback: 39
      negative_feedback: 2
      last_updated: "2025-10-14"

  # Pattern 2: SQLAlchemy Eager Loading
  - id: "py-sqlalchemy-eager-loading"
    category: "performance_optimization"
    language: "python"
    framework: "sqlalchemy"
    title: "SQLAlchemy Eager Loading for N+1 Prevention"
    confidence: 0.95
    occurrences: 31
    repositories:
      - "kellerai/api-service"
      - "kellerai/data-pipeline"
      - "kellerai/analytics-service"
    
    description: |
      Use SQLAlchemy selectinload() or joinedload() to prevent N+1 query
      problems when accessing related models in loops or iterations.
    
    pattern:
      code: |
        from sqlalchemy.orm import selectinload
        
        # Good: Eager loading prevents N+1 queries
        users = session.query(User).options(
            selectinload(User.posts),
            selectinload(User.comments)
        ).all()
        
        for user in users:
            print(user.posts)  # No additional queries
            print(user.comments)  # No additional queries
      
      detection:
        file_pattern: "**/{models,repositories}/**/*.py"
        code_pattern: "session\\.query\\(\\w+\\)"
        context: ["sqlalchemy", "relationship"]
    
    anti_pattern:
      code: |
        # Anti-pattern: Lazy loading causes N+1 queries
        users = session.query(User).all()
        
        for user in users:
            print(user.posts)  # N additional queries!
            print(user.comments)  # N more queries!
      
      detection:
        pattern: "for\\s+\\w+\\s+in.*:\\s*\\n.*\\.(\\w+\\.)+(all|first|one)\\(\\)"
        context: ["sqlalchemy"]
    
    benefits:
      - "85% average reduction in database queries"
      - "Significant performance improvement for list operations"
      - "Predictable query patterns"
    
    when_to_apply:
      - "Accessing relationships in loops"
      - "List endpoints returning related data"
      - "Any iteration over model instances with relationships"
    
    references:
      - url: "https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html"
        title: "SQLAlchemy Relationship Loading Techniques"
      - internal: "knowledge-base/PERFORMANCE_GUIDELINES.md"
        section: "database_optimization"
    
    success_metrics:
      suggestions_made: 52
      accepted: 49
      rejected: 3
      acceptance_rate: 0.94
      performance_improvement: "85% query reduction on average"
      last_updated: "2025-10-14"

  # Pattern 3: React Custom Hooks
  - id: "react-custom-hook-state"
    category: "code_structure"
    language: "typescript"
    framework: "react"
    title: "Custom Hook for Complex State Management"
    confidence: 0.88
    occurrences: 18
    repositories:
      - "kellerai/web-app"
      - "kellerai/admin-dashboard"
    
    description: |
      Extract complex component state logic into custom hooks for
      reusability, testability, and separation of concerns.
    
    pattern:
      code: |
        // Custom hook in hooks/useUserData.ts
        function useUserData(userId: string) {
          const [user, setUser] = useState<User | null>(null);
          const [loading, setLoading] = useState(true);
          const [error, setError] = useState<Error | null>(null);
          
          useEffect(() => {
            setLoading(true);
            fetchUser(userId)
              .then(setUser)
              .catch(setError)
              .finally(() => setLoading(false));
          }, [userId]);
          
          const refetch = useCallback(() => {
            fetchUser(userId).then(setUser).catch(setError);
          }, [userId]);
          
          return { user, loading, error, refetch };
        }
        
        // Component usage
        function UserProfile({ userId }: Props) {
          const { user, loading, error, refetch } = useUserData(userId);
          
          if (loading) return <LoadingSpinner />;
          if (error) return <ErrorMessage error={error} />;
          
          return <div>{user?.name}</div>;
        }
      
      detection:
        file_pattern: "**/components/**/*.{tsx,jsx}"
        code_pattern: "function\\s+\\w+.*\\{[\\s\\S]*useState[\\s\\S]*useEffect"
        complexity_threshold: 50  # Component with >50 lines
    
    anti_pattern:
      code: |
        // Anti-pattern: State logic directly in component
        function UserProfile({ userId }: Props) {
          const [user, setUser] = useState<User | null>(null);
          const [loading, setLoading] = useState(true);
          const [error, setError] = useState<Error | null>(null);
          
          useEffect(() => {
            // 30+ lines of fetching logic here
            // Not reusable, harder to test
          }, [userId]);
          
          // Large component mixing state and presentation
        }
    
    benefits:
      - "40% code reuse increase on average"
      - "Easier unit testing of state logic"
      - "Cleaner component code"
      - "Better separation of concerns"
    
    when_to_apply:
      - "Component has >50 lines of state management logic"
      - "State logic needs to be shared across components"
      - "Complex useEffect dependencies or cleanup"
      - "Data fetching with loading and error states"
    
    references:
      - url: "https://react.dev/learn/reusing-logic-with-custom-hooks"
        title: "React Custom Hooks Documentation"
      - internal: "docs/standards/coding-standards.yaml"
        section: "react_patterns"
    
    success_metrics:
      suggestions_made: 28
      accepted: 23
      rejected: 5
      acceptance_rate: 0.82
      code_reuse_increase: "40% on average"
      last_updated: "2025-10-14"

  # Pattern 4: Pytest Fixture Organization
  - id: "py-pytest-fixture-organization"
    category: "testing_strategy"
    language: "python"
    framework: "pytest"
    title: "Pytest Fixture Organization and Sharing"
    confidence: 0.83
    occurrences: 15
    repositories:
      - "kellerai/api-service"
      - "kellerai/data-pipeline"
    
    description: |
      Organize pytest fixtures in conftest.py files for reusability
      and maintain clear fixture scope (function, module, session).
    
    pattern:
      code: |
        # tests/conftest.py - Shared fixtures
        import pytest
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        
        @pytest.fixture(scope="session")
        def db_engine():
            """Database engine shared across test session."""
            engine = create_engine("sqlite:///:memory:")
            yield engine
            engine.dispose()
        
        @pytest.fixture(scope="function")
        def db_session(db_engine):
            """Clean database session for each test."""
            Session = sessionmaker(bind=db_engine)
            session = Session()
            yield session
            session.rollback()
            session.close()
        
        @pytest.fixture
        def sample_user(db_session):
            """Create a sample user for testing."""
            user = User(name="Test User", email="test@example.com")
            db_session.add(user)
            db_session.commit()
            return user
      
      detection:
        file_pattern: "**/tests/**/*.py"
        code_pattern: "@pytest\\.fixture"
    
    anti_pattern:
      code: |
        # Anti-pattern: Fixtures scattered in test files
        # tests/test_users.py
        def test_create_user():
            # Setup duplicated in every test
            engine = create_engine("sqlite:///:memory:")
            Session = sessionmaker(bind=engine)
            session = Session()
            # Test logic...
            session.close()
            engine.dispose()
    
    benefits:
      - "60% reduction in test setup code duplication"
      - "Faster test execution with proper scoping"
      - "Easier maintenance of test data"
    
    when_to_apply:
      - "Multiple tests need the same setup"
      - "Database or API client initialization"
      - "Common test data generation"
    
    references:
      - url: "https://docs.pytest.org/en/stable/fixture.html"
        title: "Pytest Fixtures Documentation"
      - internal: "docs/standards/coding-standards.yaml"
        section: "testing_standards"
    
    success_metrics:
      suggestions_made: 19
      accepted: 16
      rejected: 3
      acceptance_rate: 0.84
      code_duplication_reduction: "60%"
      last_updated: "2025-10-14"

  # Pattern 5: Python Context Manager Error Handling
  - id: "py-context-manager-error-handling"
    category: "error_handling"
    language: "python"
    framework: null
    title: "Context Manager for Resource Cleanup"
    confidence: 0.86
    occurrences: 12
    repositories:
      - "kellerai/data-pipeline"
      - "kellerai/file-processor"
    
    description: |
      Use context managers (with statements) for proper resource cleanup
      and error handling, especially for files, connections, and locks.
    
    pattern:
      code: |
        from contextlib import contextmanager
        
        @contextmanager
        def database_transaction(session):
            """Ensure transaction is committed or rolled back."""
            try:
                yield session
                session.commit()
            except Exception:
                session.rollback()
                raise
            finally:
                session.close()
        
        # Usage
        with database_transaction(session) as txn:
            txn.add(user)
            txn.add(profile)
            # Automatic commit on success, rollback on error
      
      detection:
        file_pattern: "**/*.py"
        code_pattern: "(open\\(|Session\\(|connect\\()"
        anti_pattern: "(?!with\\s+)"
    
    anti_pattern:
      code: |
        # Anti-pattern: Manual cleanup (error-prone)
        session = Session()
        try:
            session.add(user)
            session.add(profile)
            session.commit()
        except Exception:
            session.rollback()  # Easy to forget
            raise
        finally:
            session.close()  # Easy to forget
    
    benefits:
      - "Guaranteed resource cleanup"
      - "Cleaner error handling"
      - "Prevents resource leaks"
    
    when_to_apply:
      - "File operations"
      - "Database transactions"
      - "Network connections"
      - "Lock acquisition"
    
    references:
      - url: "https://docs.python.org/3/library/contextlib.html"
        title: "Python Context Managers"
      - internal: "knowledge-base/SECURITY_STANDARDS.md"
        section: "resource_management"
    
    success_metrics:
      suggestions_made: 14
      accepted: 12
      rejected: 2
      acceptance_rate: 0.86
      resource_leak_prevention: "100%"
      last_updated: "2025-10-14"

# Learning Statistics
learning_stats:
  total_suggestions: 160
  total_accepted: 141
  total_rejected: 19
  overall_acceptance_rate: 0.88
  avg_confidence_score: 0.89
  active_repositories: 8
  patterns_in_review: 3
  patterns_archived: 0

# Auto-adjustment Rules
adjustment_rules:
  increase_confidence:
    condition: "acceptance_rate > 0.90"
    adjustment: 0.05
  decrease_confidence:
    condition: "acceptance_rate < 0.70"
    adjustment: -0.05
  mark_for_review:
    condition: "negative_feedback_rate > 0.20"
  archive_pattern:
    condition: "no_usage_days > 30"
